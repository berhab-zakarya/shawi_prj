name: Smart Azure Full Stack Deployment

on:
  push:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: false
        default: 'auto'
        type: choice
        options: [auto, prod, staging, dev]
      components:
        description: 'Components to deploy'
        required: false
        default: 'all'
        type: choice
        options: [all, backend, frontend, redis]
      force_deploy:
        description: 'Force deploy all components'
        required: false
        default: false
        type: boolean
      rebuild_images:
        description: 'Rebuild Docker images from scratch (ignore cache)'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ${{ secrets.ACR_REGISTRY }}
  PROJECT_NAME: elshawi
  AZURE_REGION: westeurope

jobs:
  setup:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      deploy-backend: ${{ steps.deploy-flags.outputs.backend }}
      deploy-frontend: ${{ steps.deploy-flags.outputs.frontend }}
      deploy-redis: ${{ steps.deploy-flags.outputs.redis }}
      rebuild-images: ${{ github.event.inputs.rebuild_images == 'true' }}
      base-url: ${{ steps.env.outputs.base-url }}
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Determine Environment & Changes
      id: env
      env:
        INPUT_ENV: ${{ github.event.inputs.environment || 'auto' }}
        FORCE_DEPLOY: ${{ github.event.inputs.force_deploy == 'true' }}
      run: |
        # Smart environment detection
        if [ "$INPUT_ENV" = "auto" ]; then
          case "${{ github.ref_name }}" in
            main|master) ENV="prod" ;;
            staging) ENV="staging" ;;
            develop) ENV="dev" ;;
            *) ENV="dev" ;;
          esac
        else
          ENV="$INPUT_ENV"
        fi
        
        # Generate stable URLs
        BASE_URL="${PROJECT_NAME}-${ENV}"
        
        echo "environment=$ENV" >> $GITHUB_OUTPUT
        echo "base-url=$BASE_URL" >> $GITHUB_OUTPUT
        echo "ðŸŒ Environment: $ENV"
        echo "ðŸ”— Base URL: $BASE_URL"
        echo "ðŸ”„ Rebuild Images: $REBUILD_IMAGES"

    - name: Detect Changes
      id: changes
      uses: dorny/paths-filter@v2
      with:
        filters: |
          backend:
            - 'backend/**'
            - 'requirements.txt'
            - '**/Dockerfile*'
          frontend:
            - 'frontend/**'
            - 'package*.json'
            - '**/Dockerfile*'
          redis:
            - '.github/workflows/**'
            - 'docker-compose*'
      
    - name: Set Deploy Flags
      id: deploy-flags
      run: |
        FORCE="${{ github.event.inputs.force_deploy == 'true' }}"
        COMPONENT="${{ github.event.inputs.components || 'all' }}"
        
        # Smart deployment logic
        DEPLOY_BACKEND="false"
        DEPLOY_FRONTEND="false"
        DEPLOY_REDIS="false"
        
        if [ "$FORCE" = "true" ] || [ "$COMPONENT" = "all" ]; then
          DEPLOY_BACKEND="true"
          DEPLOY_FRONTEND="true" 
          DEPLOY_REDIS="true"
        else
          [ "${{ steps.changes.outputs.backend }}" = "true" ] && DEPLOY_BACKEND="true"
          [ "${{ steps.changes.outputs.frontend }}" = "true" ] && DEPLOY_FRONTEND="true"
          [ "${{ steps.changes.outputs.redis }}" = "true" ] && DEPLOY_REDIS="true"
          [ "$COMPONENT" = "backend" ] && DEPLOY_BACKEND="true"
          [ "$COMPONENT" = "frontend" ] && DEPLOY_FRONTEND="true"
          [ "$COMPONENT" = "redis" ] && DEPLOY_REDIS="true"
        fi
        
        echo "DEPLOY_BACKEND=$DEPLOY_BACKEND" >> $GITHUB_ENV
        echo "DEPLOY_FRONTEND=$DEPLOY_FRONTEND" >> $GITHUB_ENV
        echo "DEPLOY_REDIS=$DEPLOY_REDIS" >> $GITHUB_ENV
        
        # Also set as job outputs
        echo "backend=$DEPLOY_BACKEND" >> $GITHUB_OUTPUT
        echo "frontend=$DEPLOY_FRONTEND" >> $GITHUB_OUTPUT
        echo "redis=$DEPLOY_REDIS" >> $GITHUB_OUTPUT

  build:
    needs: setup
    runs-on: ubuntu-latest
    strategy:
      matrix:
        component: [backend, frontend]
      fail-fast: false
    steps:
    - uses: actions/checkout@v4
    - uses: docker/setup-buildx-action@v3
    - uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ secrets.ACR_USERNAME }}
        password: ${{ secrets.ACR_PASSWORD }}

    - name: Build & Push
      if: |
        (matrix.component == 'backend' && needs.setup.outputs.deploy-backend == 'true') ||
        (matrix.component == 'frontend' && needs.setup.outputs.deploy-frontend == 'true')
      env:
        REBUILD_IMAGES: ${{ needs.setup.outputs.rebuild-images }}
      uses: docker/build-push-action@v5
      with:
        context: ./${{ matrix.component }}
        file: ./${{ matrix.component }}/Dockerfile.prod
        push: true
        tags: |
          ${{ env.REGISTRY }}/${{ env.PROJECT_NAME }}-${{ matrix.component }}:${{ github.sha }}
          ${{ env.REGISTRY }}/${{ env.PROJECT_NAME }}-${{ matrix.component }}:${{ needs.setup.outputs.environment }}
        cache-from: ${{ env.REBUILD_IMAGES == 'true' && 'type=registry' || 'type=gha,scope=' }}${{ matrix.component }}
        cache-to: type=gha,scope=${{ matrix.component }},mode=max
        no-cache: ${{ env.REBUILD_IMAGES == 'true' }}

  deploy:
    needs: [setup, build]
    runs-on: ubuntu-latest
    if: always() && !cancelled()
    environment: ${{ needs.setup.outputs.environment }}
    steps:
    - name: Setup Azure API
      run: |
        cat > azure.sh << 'EOF'
        #!/bin/bash
        API_BASE="https://management.azure.com"
        RG="${{ secrets.AZURE_RESOURCE_GROUP }}"
        SUB="${{ secrets.AZURE_SUBSCRIPTION_ID }}"
        TOKEN="${{ secrets.AZURE_ACCESS_TOKEN }}"
        
        api() {
          curl -s -w "\n%{http_code}" -X "$1" \
            -H "Authorization: Bearer $TOKEN" \
            -H "Content-Type: application/json" \
            ${3:+-d "$3"} "$2"
        }
        
        deploy_container() {
          local name="$1" spec="$2"
          echo "ðŸš€ Deploying $name..."
          
          # Zero-downtime: Create new, delete old
          local url="$API_BASE/subscriptions/$SUB/resourceGroups/$RG/providers/Microsoft.ContainerInstance/containerGroups/$name?api-version=2023-05-01"
          local result=$(api PUT "$url" "$spec")
          local code=$(echo "$result" | tail -1)
          
          if [[ "$code" =~ ^(200|201)$ ]]; then
            echo "âœ… $name deployed successfully"
            return 0
          else
            echo "âŒ $name deployment failed: $code"
            echo "$result" | head -n -1
            return 1
          fi
        }
        
        wait_ready() {
          local name="$1" timeout="${2:-300}"
          echo "â³ Waiting for $name to be ready..."
          local url="$API_BASE/subscriptions/$SUB/resourceGroups/$RG/providers/Microsoft.ContainerInstance/containerGroups/$name?api-version=2023-05-01"
          
          for i in $(seq 1 $((timeout/15))); do
            local result=$(api GET "$url")
            local state=$(echo "$result" | head -n -1 | jq -r '.properties.instanceView.state // "Unknown"' 2>/dev/null)
            
            [ "$state" = "Running" ] && { echo "âœ… $name is ready!"; return 0; }
            sleep 15
          done
          
          echo "âš ï¸ $name not ready after ${timeout}s"
          return 1
        }
        
        health_check() {
          local url="$1" name="$2"
          echo "ðŸ¥ Health checking $name..."
          
          for i in {1..10}; do
            if curl -f -s --max-time 10 "$url" >/dev/null 2>&1; then
              echo "âœ… $name is healthy"
              return 0
            fi
            sleep 10
          done
          
          echo "âš ï¸ $name health check failed"
          return 1
        }
        EOF
        chmod +x azure.sh

    - name: Deploy Redis
      if: env.DEPLOY_REDIS == 'true'
      env:
        BASE_URL: ${{ needs.setup.outputs.base-url }}
        ENV: ${{ needs.setup.outputs.environment }}
      run: |
        source azure.sh
        
        REDIS_SPEC='{
          "location": "${{ env.AZURE_REGION }}",
          "properties": {
            "containers": [{
              "name": "redis",
              "properties": {
                "image": "redis:7-alpine",
                "command": ["redis-server", "--appendonly", "yes", "--maxmemory", "512mb", "--maxmemory-policy", "allkeys-lru"],
                "ports": [{"port": 6379, "protocol": "TCP"}],
                "resources": {"requests": {"cpu": 0.5, "memoryInGB": 0.5}}
              }
            }],
            "osType": "Linux",
            "ipAddress": {
              "type": "Public",
              "ports": [{"port": 6379, "protocol": "TCP"}],
              "dnsNameLabel": "'${BASE_URL}'-redis"
            },
            "restartPolicy": "Always"
          }
        }'
        
        deploy_container "${BASE_URL}-redis" "$REDIS_SPEC"
        wait_ready "${BASE_URL}-redis" 180

    - name: Deploy Backend
      if: env.DEPLOY_BACKEND == 'true'
      env:
        BASE_URL: ${{ needs.setup.outputs.base-url }}
        ENV: ${{ needs.setup.outputs.environment }}
      run: |
        source azure.sh
        
        BACKEND_SPEC='{
          "location": "${{ env.AZURE_REGION }}",
          "properties": {
            "containers": [{
              "name": "backend",
              "properties": {
                "image": "${{ env.REGISTRY }}/${{ env.PROJECT_NAME }}-backend:${{ github.sha }}",
                "ports": [{"port": 8000, "protocol": "TCP"}],
                "environmentVariables": [
                  {"name": "DJANGO_SECRET_KEY", "value": "${{ secrets.DJANGO_SECRET_KEY }}"},
                  {"name": "DJANGO_DEBUG", "value": "'$([[ "$ENV" == "prod" ]] && echo "False" || echo "True")'"},
                  {"name": "DJANGO_ALLOWED_HOSTS", "value": "'${BASE_URL}'-backend.${{ env.AZURE_REGION }}.azurecontainer.io,*"},
                  {"name": "REDIS_URL", "value": "redis://'${BASE_URL}'-redis.${{ env.AZURE_REGION }}.azurecontainer.io:6379"},
                  {"name": "CORS_ALLOWED_ORIGINS", "value": "https://'${BASE_URL}'-frontend.${{ env.AZURE_REGION }}.azurecontainer.io"},
                  {"name": "DATABASE_URL", "value": "sqlite:///db.sqlite3"}
                ],
                "resources": {"requests": {"cpu": 1, "memoryInGB": 1.5}}
              }
            }],
            "imageRegistryCredentials": [{
              "server": "${{ env.REGISTRY }}",
              "username": "${{ secrets.ACR_USERNAME }}",
              "password": "${{ secrets.ACR_PASSWORD }}"
            }],
            "osType": "Linux",
            "ipAddress": {
              "type": "Public",
              "ports": [{"port": 8000, "protocol": "TCP"}],
              "dnsNameLabel": "'${BASE_URL}'-backend"
            },
            "restartPolicy": "Always"
          }
        }'
        
        deploy_container "${BASE_URL}-backend" "$BACKEND_SPEC"
        wait_ready "${BASE_URL}-backend" 300

    - name: Deploy Frontend
      if: env.DEPLOY_FRONTEND == 'true'
      env:
        BASE_URL: ${{ needs.setup.outputs.base-url }}
        ENV: ${{ needs.setup.outputs.environment }}
      run: |
        source azure.sh
        
        FRONTEND_SPEC='{
          "location": "${{ env.AZURE_REGION }}",
          "properties": {
            "containers": [{
              "name": "frontend",
              "properties": {
                "image": "${{ env.REGISTRY }}/${{ env.PROJECT_NAME }}-frontend:${{ github.sha }}",
                "ports": [{"port": 3000, "protocol": "TCP"}],
                "environmentVariables": [
                  {"name": "NEXT_PUBLIC_API_URL", "value": "http://'${BASE_URL}'-backend.${{ env.AZURE_REGION }}.azurecontainer.io:8000"},
                  {"name": "NODE_ENV", "value": "production"}
                ],
                "resources": {"requests": {"cpu": 1, "memoryInGB": 1}}
              }
            }],
            "imageRegistryCredentials": [{
              "server": "${{ env.REGISTRY }}",
              "username": "${{ secrets.ACR_USERNAME }}",
              "password": "${{ secrets.ACR_PASSWORD }}"
            }],
            "osType": "Linux",
            "ipAddress": {
              "type": "Public",
              "ports": [{"port": 3000, "protocol": "TCP"}],
              "dnsNameLabel": "'${BASE_URL}'-frontend"
            },
            "restartPolicy": "Always"
          }
        }'
        
        deploy_container "${BASE_URL}-frontend" "$FRONTEND_SPEC"
        wait_ready "${BASE_URL}-frontend" 300

  health-check:
    needs: [setup, deploy]
    runs-on: ubuntu-latest
    if: always() && needs.deploy.result == 'success'
    steps:
    - name: Comprehensive Health Check
      env:
        BASE_URL: ${{ needs.setup.outputs.base-url }}
        REGION: ${{ env.AZURE_REGION }}
        DEPLOY_REDIS: ${{ needs.setup.outputs.deploy-redis }}
        DEPLOY_BACKEND: ${{ needs.setup.outputs.deploy-backend }}
        DEPLOY_FRONTEND: ${{ needs.setup.outputs.deploy-frontend }}
        AZURE_ACCESS_TOKEN: ${{ secrets.AZURE_ACCESS_TOKEN }}
        AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        AZURE_RESOURCE_GROUP: ${{ secrets.AZURE_RESOURCE_GROUP }}
      run: |
        # Enhanced health check with container status verification
        check_container_status() {
          local container_name="$1"
          echo "ðŸ” Checking container status: $container_name"
          
          local api_url="https://management.azure.com/subscriptions/$AZURE_SUBSCRIPTION_ID/resourceGroups/$AZURE_RESOURCE_GROUP/providers/Microsoft.ContainerInstance/containerGroups/$container_name?api-version=2023-05-01"
          
          local response=$(curl -s -H "Authorization: Bearer $AZURE_ACCESS_TOKEN" "$api_url")
          local state=$(echo "$response" | jq -r '.properties.instanceView.state // "Unknown"' 2>/dev/null)
          local provisioning_state=$(echo "$response" | jq -r '.properties.provisioningState // "Unknown"' 2>/dev/null)
          
          echo "  State: $state, Provisioning: $provisioning_state"
          
          if [ "$state" = "Running" ] && [ "$provisioning_state" = "Succeeded" ]; then
            return 0
          else
            return 1
          fi
        }
        
        # DNS resolution check
        check_dns() {
          local hostname="$1"
          echo "ðŸŒ Checking DNS resolution for $hostname"
          
          for i in {1..5}; do
            if nslookup "$hostname" >/dev/null 2>&1; then
              echo "âœ… DNS resolved successfully"
              return 0
            fi
            echo "  Attempt $i/5 failed, waiting..."
            sleep 15
          done
          
          echo "âš ï¸ DNS resolution failed"
          return 1
        }
        
        # Enhanced health check function
        health_check() {
          local url="$1" name="$2" max_attempts="${3:-15}"
          echo "ðŸ¥ Health checking $name at $url"
          
          for i in $(seq 1 $max_attempts); do
            echo "  Attempt $i/$max_attempts..."
            
            # Try multiple HTTP methods and endpoints
            for endpoint in "" "/health/" "/api/health/" "/ping"; do
              local test_url="${url%/}${endpoint}"
              
              # Try different curl strategies
              if curl -f -s --max-time 15 --connect-timeout 10 "$test_url" >/dev/null 2>&1; then
                echo "âœ… $name is healthy (endpoint: $endpoint)"
                return 0
              elif curl -s --max-time 15 --connect-timeout 10 "$test_url" 2>&1 | grep -q "200\|301\|302\|404"; then
                echo "âœ… $name is responding (endpoint: $endpoint)"
                return 0
              fi
            done
            
            # Progressive wait times
            local wait_time=$((i <= 5 ? 15 : i <= 10 ? 30 : 45))
            echo "  Waiting ${wait_time}s before next attempt..."
            sleep $wait_time
          done
          
          echo "âš ï¸ $name health check failed after $max_attempts attempts"
          return 1
        }
        
        # Redis health check function
        redis_health_check() {
          local host="$1"
          echo "ðŸ¥ Redis health checking $host:6379"
          
          for i in {1..10}; do
            echo "  Attempt $i/10..."
            
            # Try multiple methods
            if timeout 10 bash -c "echo 'PING' | nc -w 5 $host 6379" 2>/dev/null | grep -q PONG; then
              echo "âœ… Redis is healthy (nc method)"
              return 0
            elif timeout 10 bash -c "</dev/tcp/$host/6379" 2>/dev/null; then
              echo "âœ… Redis port is open (tcp method)"
              return 0
            elif timeout 10 redis-cli -h "$host" -p 6379 ping 2>/dev/null | grep -q PONG; then
              echo "âœ… Redis is healthy (redis-cli method)"
              return 0
            fi
            
            sleep 20
          done
          
          echo "âš ï¸ Redis health check failed"
          return 1
        }
        
        echo "ðŸ¥ Starting comprehensive health checks..."
        echo "=================================================="
        
        # Initial wait for containers to stabilize
        echo "â³ Initial stabilization wait (60s)..."
        sleep 60
        
        # Health check URLs
        REDIS_HOST="${BASE_URL}-redis.${REGION}.azurecontainer.io"
        BACKEND_URL="http://${BASE_URL}-backend.${REGION}.azurecontainer.io:8000"
        FRONTEND_URL="http://${BASE_URL}-frontend.${REGION}.azurecontainer.io:3000"
        
        # Check Redis
        if [ "$DEPLOY_REDIS" = "true" ]; then
          echo "ðŸ”´ Checking Redis..."
          check_container_status "${BASE_URL}-redis"
          check_dns "$REDIS_HOST"
          redis_health_check "$REDIS_HOST" || echo "âš ï¸ Redis health check failed but continuing..."
        fi
        
        # Check Backend
        if [ "$DEPLOY_BACKEND" = "true" ]; then
          echo "ðŸŸ¡ Checking Backend..."
          check_container_status "${BASE_URL}-backend"
          check_dns "${BASE_URL}-backend.${REGION}.azurecontainer.io"
          health_check "$BACKEND_URL" "Backend" 20 || echo "âš ï¸ Backend health check failed but continuing..."
        fi
        
        # Check Frontend
        if [ "$DEPLOY_FRONTEND" = "true" ]; then
          echo "ðŸŸ¢ Checking Frontend..."
          check_container_status "${BASE_URL}-frontend"
          check_dns "${BASE_URL}-frontend.${REGION}.azurecontainer.io"
          health_check "$FRONTEND_URL" "Frontend" 15 || echo "âš ï¸ Frontend health check failed but continuing..."
        fi
        
        echo "=================================================="
        echo "ðŸ¥ Health check phase completed"
        echo "ðŸ’¡ Note: Some checks may fail initially due to DNS propagation"
        echo "ðŸ’¡ Services should be accessible within 5-10 minutes"

  cleanup:
    needs: [setup, health-check]
    runs-on: ubuntu-latest
    if: always() && (needs.health-check.result == 'success' || needs.health-check.result == 'failure')
    steps:
    - name: Intelligent Cleanup
      env:
        BASE_URL: ${{ needs.setup.outputs.base-url }}
        AZURE_ACCESS_TOKEN: ${{ secrets.AZURE_ACCESS_TOKEN }}
        AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        AZURE_RESOURCE_GROUP: ${{ secrets.AZURE_RESOURCE_GROUP }}
      run: |
        # Azure API helper
        API_BASE="https://management.azure.com"
        RG="$AZURE_RESOURCE_GROUP"
        SUB="$AZURE_SUBSCRIPTION_ID"
        TOKEN="$AZURE_ACCESS_TOKEN"
        
        api() {
          curl -s -w "\n%{http_code}" -X "$1" \
            -H "Authorization: Bearer $TOKEN" \
            -H "Content-Type: application/json" \
            ${3:+-d "$3"} "$2"
        }
        
        echo "ðŸ§¹ Cleaning up old deployments..."
        
        # List all containers
        containers_url="$API_BASE/subscriptions/$SUB/resourceGroups/$RG/providers/Microsoft.ContainerInstance/containerGroups?api-version=2023-05-01"
        all_containers=$(api GET "$containers_url" | head -n -1 | jq -r '.value[].name' 2>/dev/null | grep "^${{ env.PROJECT_NAME }}-" || true)
        
        # Keep current environment + last 2 deployments per environment
        current_containers="$BASE_URL-redis $BASE_URL-backend $BASE_URL-frontend"
        keep_containers=$(echo "$all_containers" | grep -E "(prod|staging|dev)" | sort -r | head -9 || true)
        
        # Delete old containers
        for container in $all_containers; do
          if ! echo "$keep_containers" | grep -q "$container"; then
            echo "ðŸ—‘ï¸ Deleting old container: $container"
            delete_url="$API_BASE/subscriptions/$SUB/resourceGroups/$RG/providers/Microsoft.ContainerInstance/containerGroups/$container?api-version=2023-05-01"
            api DELETE "$delete_url" >/dev/null &
          fi
        done
        wait

  notify:
    needs: [setup, deploy, health-check, cleanup]
    runs-on: ubuntu-latest
    if: always()
    steps:
    - name: Deployment Summary
      env:
        BASE_URL: ${{ needs.setup.outputs.base-url }}
        ENV: ${{ needs.setup.outputs.environment }}
        REGION: ${{ env.AZURE_REGION }}
        DEPLOY_REDIS: ${{ needs.setup.outputs.deploy-redis }}
        DEPLOY_BACKEND: ${{ needs.setup.outputs.deploy-backend }}
        DEPLOY_FRONTEND: ${{ needs.setup.outputs.deploy-frontend }}
      run: |
        echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "| Component | Status | URL |" >> $GITHUB_STEP_SUMMARY
        echo "|-----------|--------|-----|" >> $GITHUB_STEP_SUMMARY
        echo "| Environment | $ENV | - |" >> $GITHUB_STEP_SUMMARY
        echo "| Rebuild Mode | ${{ needs.setup.outputs.rebuild-images == 'true' && 'ðŸ”„ Full Rebuild' || 'âš¡ Cache Used' }} | - |" >> $GITHUB_STEP_SUMMARY
        
        [ "${{ needs.deploy.result }}" = "success" ] && STATUS="âœ… Success" || STATUS="âŒ Failed"
        echo "| Deployment | $STATUS | - |" >> $GITHUB_STEP_SUMMARY
        
        if [ "$DEPLOY_REDIS" = "true" ]; then
          echo "| Redis | âœ… Deployed | ${BASE_URL}-redis.${REGION}.azurecontainer.io:6379 |" >> $GITHUB_STEP_SUMMARY
        fi
        
        if [ "$DEPLOY_BACKEND" = "true" ]; then
          echo "| Backend | âœ… Deployed | http://${BASE_URL}-backend.${REGION}.azurecontainer.io:8000 |" >> $GITHUB_STEP_SUMMARY
        fi
        
        if [ "$DEPLOY_FRONTEND" = "true" ]; then
          echo "| Frontend | âœ… Deployed | http://${BASE_URL}-frontend.${REGION}.azurecontainer.io:3000 |" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ”— Quick Links" >> $GITHUB_STEP_SUMMARY
        echo "- ðŸŒ **App**: http://${BASE_URL}-frontend.${REGION}.azurecontainer.io:3000" >> $GITHUB_STEP_SUMMARY
        echo "- ðŸ”§ **Admin**: http://${BASE_URL}-backend.${REGION}.azurecontainer.io:8000/admin/" >> $GITHUB_STEP_SUMMARY
        echo "- ðŸ“Š **API Docs**: http://${BASE_URL}-backend.${REGION}.azurecontainer.io:8000/docs/" >> $GITHUB_STEP_SUMMARY