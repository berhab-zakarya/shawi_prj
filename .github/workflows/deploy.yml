name: Smart Deploy Full Stack App to Azure

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deploy all components'
        required: false
        default: false
        type: boolean
      component:
        description: 'Deploy specific component (backend/frontend/redis/all)'
        required: false
        default: 'all'
        type: choice
        options:
        - all
        - backend
        - frontend
        - redis

env:
  REGISTRY: ${{ secrets.ACR_REGISTRY }}
  BACKEND_IMAGE_NAME: elshawi-backend
  FRONTEND_IMAGE_NAME: elshawi-frontend
  AZURE_API_BASE: https://management.azure.com

jobs:
  azure-setup:
    runs-on: ubuntu-latest
    outputs:
      auth-verified: ${{ steps.verify-auth.outputs.verified }}
    steps:
    - name: Verify Azure Access Token
      id: verify-auth
      env:
        AZURE_ACCESS_TOKEN: ${{ secrets.AZURE_ACCESS_TOKEN }}
        AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        AZURE_RESOURCE_GROUP: ${{ secrets.AZURE_RESOURCE_GROUP }}
      run: |
        echo "ðŸ§¹ Cleaning up old deployments..."
        
        # Get all containers with our prefix
        ALL_CONTAINERS=$(list_containers)
        CURRENT_CONTAINERS="elshawi-backend-${GITHUB_RUN_NUMBER}
        elshawi-frontend-${GITHUB_RUN_NUMBER}
        elshawi-redis-${GITHUB_RUN_NUMBER}"
        
        if [ -n "$ALL_CONTAINERS" ]; then
          # Keep last 2 deployments (6 containers total)
          OLD_CONTAINERS=$(echo "$ALL_CONTAINERS" | grep -v -F "$CURRENT_CONTAINERS" | head -n -6 || true)
          
          if [ -n "$OLD_CONTAINERS" ]; then
            echo "ðŸ—‘ï¸ Deleting old containers:"
            echo "$OLD_CONTAINERS"
            
            for container in $OLD_CONTAINERS; do
              echo "Deleting: $container"
              delete_container "$container" &
            done
            
            # Wait for all deletions to complete
            wait
            echo "âœ… Cleanup completed"
          else
            echo "âœ¨ No old containers to cleanup"
          fi
        else
          echo "âœ¨ No containers found for cleanup"
        fi

  notification:
    needs: [azure-setup, detect-changes, deploy]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
    - name: Deployment Status Summary
      env:
        GITHUB_RUN_NUMBER: ${{ github.run_number }}
      run: |
        echo "ðŸ“‹ Final Deployment Status"
        echo "=================================="
        echo "Azure Setup: ${{ needs.azure-setup.result }}"
        echo "Change Detection: ${{ needs.detect-changes.result }}"
        echo "Deployment: ${{ needs.deploy.result }}"
        echo "Backend Should Deploy: ${{ needs.detect-changes.outputs.should-deploy-backend }}"
        echo "Frontend Should Deploy: ${{ needs.detect-changes.outputs.should-deploy-frontend }}"
        echo "Redis Should Deploy: ${{ needs.detect-changes.outputs.should-deploy-redis }}"
        echo "=================================="
        
        if [ "${{ needs.deploy.result }}" == "success" ]; then
          echo "âœ… Deployment completed successfully!"
          echo "ðŸŒ Your app should be live at:"
          if [ "${{ needs.detect-changes.outputs.should-deploy-frontend }}" == "true" ]; then
            echo "Frontend: https://elshawi-frontend-${GITHUB_RUN_NUMBER}.westeurope.azurecontainer.io:3000"
          fi
          if [ "${{ needs.detect-changes.outputs.should-deploy-backend }}" == "true" ]; then
            echo "Backend: https://elshawi-backend-${GITHUB_RUN_NUMBER}.westeurope.azurecontainer.io:8000"
          fi
        elif [ "${{ needs.deploy.result }}" == "skipped" ]; then
          echo "â­ï¸ Deployment was skipped (no components needed deployment)"
        else
          echo "âŒ Deployment failed or was cancelled"
          exit 1
        fi "ðŸ” Verifying Azure access token..."
        
        # Test the access token with subscription info
        HTTP_CODE=$(curl -s -w "%{http_code}" -o /tmp/sub_response.json \
          -H "Authorization: Bearer ${AZURE_ACCESS_TOKEN}" \
          -H "Content-Type: application/json" \
          "${AZURE_API_BASE}/subscriptions/${AZURE_SUBSCRIPTION_ID}?api-version=2020-01-01")
        
        if [ "$HTTP_CODE" = "200" ]; then
          echo "âœ… Access token is valid"
          SUB_NAME=$(cat /tmp/sub_response.json | jq -r '.displayName')
          echo "ðŸ“‹ Subscription: $SUB_NAME"
          echo "verified=true" >> $GITHUB_OUTPUT
        else
          echo "âŒ Access token validation failed with HTTP code: $HTTP_CODE"
          cat /tmp/sub_response.json
          echo "verified=false" >> $GITHUB_OUTPUT
          exit 1
        fi

  detect-changes:
    needs: azure-setup
    runs-on: ubuntu-latest
    outputs:
      backend-changed: ${{ steps.changes.outputs.backend }}
      frontend-changed: ${{ steps.changes.outputs.frontend }}
      docker-changed: ${{ steps.changes.outputs.docker }}
      workflow-changed: ${{ steps.changes.outputs.workflow }}
      force-deploy: ${{ github.event.inputs.force_deploy == 'true' || github.event_name == 'workflow_dispatch' }}
      deploy-component: ${{ github.event.inputs.component || 'all' }}
      should-deploy-backend: ${{ steps.deployment-logic.outputs.deploy-backend }}
      should-deploy-frontend: ${{ steps.deployment-logic.outputs.deploy-frontend }}
      should-deploy-redis: ${{ steps.deployment-logic.outputs.deploy-redis }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Detect file changes
      uses: dorny/paths-filter@v2
      id: changes
      with:
        filters: |
          backend:
            - 'backend/**'
            - 'requirements.txt'
            - 'pyproject.toml'
            - 'poetry.lock'
          frontend:
            - 'frontend/**'
            - 'package.json'
            - 'package-lock.json'
            - 'yarn.lock'
            - 'pnpm-lock.yaml'
          docker:
            - '**/Dockerfile*'
            - '**/.dockerignore'
            - 'docker-compose*'
          workflow:
            - '.github/workflows/**'

    - name: Determine deployment logic
      id: deployment-logic
      env:
        BACKEND_CHANGED: ${{ steps.changes.outputs.backend }}
        FRONTEND_CHANGED: ${{ steps.changes.outputs.frontend }}
        DOCKER_CHANGED: ${{ steps.changes.outputs.docker }}
        FORCE_DEPLOY: ${{ github.event.inputs.force_deploy == 'true' || github.event_name == 'workflow_dispatch' }}
        DEPLOY_COMPONENT: ${{ github.event.inputs.component || 'all' }}
      run: |
        echo "ðŸ” Determining what to deploy..."
        
        # Backend deployment logic
        if [[ "$BACKEND_CHANGED" == "true" || "$DOCKER_CHANGED" == "true" || "$FORCE_DEPLOY" == "true" ]] || \
           [[ "$DEPLOY_COMPONENT" == "all" || "$DEPLOY_COMPONENT" == "backend" ]]; then
          echo "deploy-backend=true" >> $GITHUB_OUTPUT
          echo "âœ… Backend will be deployed"
        else
          echo "deploy-backend=false" >> $GITHUB_OUTPUT
          echo "â­ï¸ Backend deployment skipped"
        fi
        
        # Frontend deployment logic
        if [[ "$FRONTEND_CHANGED" == "true" || "$DOCKER_CHANGED" == "true" || "$FORCE_DEPLOY" == "true" ]] || \
           [[ "$DEPLOY_COMPONENT" == "all" || "$DEPLOY_COMPONENT" == "frontend" ]]; then
          echo "deploy-frontend=true" >> $GITHUB_OUTPUT
          echo "âœ… Frontend will be deployed"
        else
          echo "deploy-frontend=false" >> $GITHUB_OUTPUT
          echo "â­ï¸ Frontend deployment skipped"
        fi
        
        # Redis deployment logic (deploy if backend needs deployment or explicitly requested)
        if [[ "$BACKEND_CHANGED" == "true" || "$FORCE_DEPLOY" == "true" ]] || \
           [[ "$DEPLOY_COMPONENT" == "all" || "$DEPLOY_COMPONENT" == "redis" || "$DEPLOY_COMPONENT" == "backend" ]]; then
          echo "deploy-redis=true" >> $GITHUB_OUTPUT
          echo "âœ… Redis will be deployed"
        else
          echo "deploy-redis=false" >> $GITHUB_OUTPUT
          echo "â­ï¸ Redis deployment skipped"
        fi

    - name: Show detected changes
      run: |
        echo "ðŸ” Change Detection Results:"
        echo "=================================="
        echo "Backend changed: ${{ steps.changes.outputs.backend }}"
        echo "Frontend changed: ${{ steps.changes.outputs.frontend }}"
        echo "Docker files changed: ${{ steps.changes.outputs.docker }}"
        echo "Workflow changed: ${{ steps.changes.outputs.workflow }}"
        echo "Force deploy: ${{ github.event.inputs.force_deploy == 'true' || github.event_name == 'workflow_dispatch' }}"
        echo "Deploy component: ${{ github.event.inputs.component || 'all' }}"
        echo "=================================="
        echo "ðŸ“‹ Deployment Decisions:"
        echo "Deploy Backend: ${{ steps.deployment-logic.outputs.deploy-backend }}"
        echo "Deploy Frontend: ${{ steps.deployment-logic.outputs.deploy-frontend }}"
        echo "Deploy Redis: ${{ steps.deployment-logic.outputs.deploy-redis }}"
        echo "=================================="

  build-backend:
    needs: [azure-setup, detect-changes]
    runs-on: ubuntu-latest
    if: needs.detect-changes.outputs.should-deploy-backend == 'true'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Azure Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ secrets.ACR_USERNAME }}
        password: ${{ secrets.ACR_PASSWORD }}

    - name: Build and push Backend (Django) image
      uses: docker/build-push-action@v5
      with:
        context: ./backend
        file: ./backend/Dockerfile.prod
        push: true
        tags: |
          ${{ env.REGISTRY }}/${{ env.BACKEND_IMAGE_NAME }}:${{ github.sha }}
          ${{ env.REGISTRY }}/${{ env.BACKEND_IMAGE_NAME }}:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64

  build-frontend:
    needs: [azure-setup, detect-changes]
    runs-on: ubuntu-latest
    if: needs.detect-changes.outputs.should-deploy-frontend == 'true'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Azure Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ secrets.ACR_USERNAME }}
        password: ${{ secrets.ACR_PASSWORD }}

    - name: Build and push Frontend (Next.js) image
      uses: docker/build-push-action@v5
      with:
        context: ./frontend
        file: ./frontend/Dockerfile.prod
        push: true
        tags: |
          ${{ env.REGISTRY }}/${{ env.FRONTEND_IMAGE_NAME }}:${{ github.sha }}
          ${{ env.REGISTRY }}/${{ env.FRONTEND_IMAGE_NAME }}:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64

  deploy:
    needs: [azure-setup, detect-changes, build-backend, build-frontend]
    runs-on: ubuntu-latest
    if: always() && !cancelled() && needs.azure-setup.result == 'success' && needs.detect-changes.result == 'success' && (needs.detect-changes.outputs.should-deploy-backend == 'true' || needs.detect-changes.outputs.should-deploy-frontend == 'true' || needs.detect-changes.outputs.should-deploy-redis == 'true')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Azure REST API Helper Functions
      env:
        AZURE_ACCESS_TOKEN: ${{ secrets.AZURE_ACCESS_TOKEN }}
        AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        AZURE_RESOURCE_GROUP: ${{ secrets.AZURE_RESOURCE_GROUP }}
      run: |
        echo "ðŸ”§ Setting up Azure REST API helper functions..."
        
        # Create helper functions for Azure REST API calls
        cat > azure_rest_helper.sh << 'EOF'
        #!/bin/bash
        
        # Azure REST API helper functions
        AZURE_TOKEN="${AZURE_ACCESS_TOKEN}"
        SUBSCRIPTION_ID="${AZURE_SUBSCRIPTION_ID}"
        RESOURCE_GROUP="${AZURE_RESOURCE_GROUP}"
        API_BASE="https://management.azure.com"
        
        # Function to make authenticated REST API calls
        azure_api_call() {
          local method="$1"
          local url="$2"
          local data="$3"
          
          if [ -n "$data" ]; then
            curl -s -X "$method" \
              -H "Authorization: Bearer $AZURE_TOKEN" \
              -H "Content-Type: application/json" \
              -d "$data" \
              "$url"
          else
            curl -s -X "$method" \
              -H "Authorization: Bearer $AZURE_TOKEN" \
              -H "Content-Type: application/json" \
              "$url"
          fi
        }
        
        # Function to check if container instance exists
        check_container_exists() {
          local container_name="$1"
          local url="$API_BASE/subscriptions/$SUBSCRIPTION_ID/resourceGroups/$RESOURCE_GROUP/providers/Microsoft.ContainerInstance/containerGroups/$container_name?api-version=2021-09-01"
          
          local response=$(azure_api_call "GET" "$url")
          local http_code=$(echo "$response" | jq -r '.error.code // empty' 2>/dev/null)
          
          if [ "$http_code" = "ResourceNotFound" ] || [ "$http_code" = "NotFound" ]; then
            echo ""
          else
            echo "$response" | jq -r '.name // empty' 2>/dev/null
          fi
        }
        
        # Function to delete container instance
        delete_container() {
          local container_name="$1"
          local url="$API_BASE/subscriptions/$SUBSCRIPTION_ID/resourceGroups/$RESOURCE_GROUP/providers/Microsoft.ContainerInstance/containerGroups/$container_name?api-version=2021-09-01"
          
          echo "ðŸ—‘ï¸ Deleting container: $container_name"
          local result=$(azure_api_call "DELETE" "$url")
          echo "Delete result: $result"
        }
        
        # Function to create container instance with error handling
        create_container() {
          local container_name="$1"
          local container_spec="$2"
          local url="$API_BASE/subscriptions/$SUBSCRIPTION_ID/resourceGroups/$RESOURCE_GROUP/providers/Microsoft.ContainerInstance/containerGroups/$container_name?api-version=2021-09-01"
          
          echo "ðŸš€ Creating container: $container_name"
          local result=$(azure_api_call "PUT" "$url" "$container_spec")
          
          # Check for errors
          local error_code=$(echo "$result" | jq -r '.error.code // empty' 2>/dev/null)
          if [ -n "$error_code" ]; then
            echo "âŒ Container creation failed:"
            echo "$result" | jq '.error' 2>/dev/null || echo "$result"
            return 1
          else
            echo "âœ… Container creation initiated successfully"
            return 0
          fi
        }
        
        # Function to get container status
        get_container_status() {
          local container_name="$1"
          local url="$API_BASE/subscriptions/$SUBSCRIPTION_ID/resourceGroups/$RESOURCE_GROUP/providers/Microsoft.ContainerInstance/containerGroups/$container_name?api-version=2021-09-01"
          
          local response=$(azure_api_call "GET" "$url")
          echo "$response" | jq -r '.properties.instanceView.state // "Unknown"' 2>/dev/null
        }
        
        # Function to wait for container to be ready
        wait_for_container() {
          local container_name="$1"
          local max_attempts=20
          local attempt=1
          
          echo "â³ Waiting for container $container_name to be ready..."
          
          while [ $attempt -le $max_attempts ]; do
            local status=$(get_container_status "$container_name")
            echo "Attempt $attempt/$max_attempts - Status: $status"
            
            if [ "$status" = "Running" ]; then
              echo "âœ… Container $container_name is running"
              return 0
            elif [ "$status" = "Failed" ] || [ "$status" = "Terminated" ]; then
              echo "âŒ Container $container_name failed to start"
              return 1
            fi
            
            sleep 15
            ((attempt++))
          done
          
          echo "âš ï¸ Container $container_name did not start within expected time"
          return 1
        }
        EOF
        
        chmod +x azure_rest_helper.sh

    - name: Check existing deployments
      id: check-deployments
      env:
        GITHUB_RUN_NUMBER: ${{ github.run_number }}
      run: |
        source azure_rest_helper.sh
        
        echo "ðŸ” Checking existing deployments..."
        
        # Check if containers already exist
        BACKEND_EXISTS=$(check_container_exists "elshawi-backend-${GITHUB_RUN_NUMBER}")
        FRONTEND_EXISTS=$(check_container_exists "elshawi-frontend-${GITHUB_RUN_NUMBER}")
        REDIS_EXISTS=$(check_container_exists "elshawi-redis-${GITHUB_RUN_NUMBER}")
        
        echo "backend-exists=${BACKEND_EXISTS}" >> $GITHUB_OUTPUT
        echo "frontend-exists=${FRONTEND_EXISTS}" >> $GITHUB_OUTPUT
        echo "redis-exists=${REDIS_EXISTS}" >> $GITHUB_OUTPUT
        
        echo "Backend exists: ${BACKEND_EXISTS:-none}"
        echo "Frontend exists: ${FRONTEND_EXISTS:-none}"
        echo "Redis exists: ${REDIS_EXISTS:-none}"

    - name: Deploy Redis (if needed)
      if: needs.detect-changes.outputs.should-deploy-redis == 'true' && steps.check-deployments.outputs.redis-exists == ''
      env:
        GITHUB_RUN_NUMBER: ${{ github.run_number }}
      run: |
        source azure_rest_helper.sh
        
        echo "ðŸš€ Deploying Redis..."
        
        # Redis container specification
        REDIS_SPEC=$(cat << EOF
        {
          "location": "westeurope",
          "properties": {
            "containers": [
              {
                "name": "redis",
                "properties": {
                  "image": "redis:7-alpine",
                  "command": ["redis-server", "--appendonly", "yes", "--maxmemory", "256mb", "--maxmemory-policy", "allkeys-lru"],
                  "ports": [
                    {
                      "port": 6379,
                      "protocol": "TCP"
                    }
                  ],
                  "resources": {
                    "requests": {
                      "cpu": 0.5,
                      "memoryInGB": 0.5
                    }
                  }
                }
              }
            ],
            "osType": "Linux",
            "ipAddress": {
              "type": "Public",
              "ports": [
                {
                  "port": 6379,
                  "protocol": "TCP"
                }
              ],
              "dnsNameLabel": "elshawi-redis-${GITHUB_RUN_NUMBER}"
            },
            "restartPolicy": "Always"
          }
        }
        EOF
        )
        
        if create_container "elshawi-redis-${GITHUB_RUN_NUMBER}" "$REDIS_SPEC"; then
          wait_for_container "elshawi-redis-${GITHUB_RUN_NUMBER}"
        else
          echo "âŒ Failed to create Redis container"
          exit 1
        fi

    - name: Deploy Backend
      if: needs.detect-changes.outputs.should-deploy-backend == 'true' && (needs.build-backend.result == 'success' || needs.build-backend.result == 'skipped')
      env:
        GITHUB_RUN_NUMBER: ${{ github.run_number }}
        GITHUB_SHA: ${{ github.sha }}
        REGISTRY: ${{ env.REGISTRY }}
        BACKEND_IMAGE_NAME: ${{ env.BACKEND_IMAGE_NAME }}
        DJANGO_SECRET_KEY: ${{ secrets.DJANGO_SECRET_KEY }}
        ACR_USERNAME: ${{ secrets.ACR_USERNAME }}
        ACR_PASSWORD: ${{ secrets.ACR_PASSWORD }}
      run: |
        source azure_rest_helper.sh
        
        echo "ðŸš€ Deploying Backend..."
        
        # Delete existing container if it exists
        if [ "${{ steps.check-deployments.outputs.backend-exists }}" != "" ]; then
          delete_container "elshawi-backend-${GITHUB_RUN_NUMBER}"
          sleep 10
        fi
        
        # Backend container specification
        BACKEND_SPEC=$(cat << EOF
        {
          "location": "westeurope",
          "properties": {
            "containers": [
              {
                "name": "backend",
                "properties": {
                  "image": "${REGISTRY}/${BACKEND_IMAGE_NAME}:latest",
                  "ports": [
                    {
                      "port": 8000,
                      "protocol": "TCP"
                    }
                  ],
                  "environmentVariables": [
                    {"name": "DJANGO_SECRET_KEY", "value": "${DJANGO_SECRET_KEY}"},
                    {"name": "DJANGO_DEBUG", "value": "False"},
                    {"name": "DJANGO_ALLOWED_HOSTS", "value": "elshawi-backend-${GITHUB_RUN_NUMBER}.westeurope.azurecontainer.io,localhost"},
                    {"name": "REDIS_URL", "value": "elshawi-redis-${GITHUB_RUN_NUMBER}.westeurope.azurecontainer.io:6379"},
                    {"name": "DATABASE_URL", "value": "sqlite:///db.sqlite3"},
                    {"name": "CORS_ALLOWED_ORIGINS", "value": "https://elshawi-frontend-${GITHUB_RUN_NUMBER}.westeurope.azurecontainer.io"},
                    {"name": "GUNICORN_WORKERS", "value": "2"},
                    {"name": "GUNICORN_TIMEOUT", "value": "30"}
                  ],
                  "resources": {
                    "requests": {
                      "cpu": 1,
                      "memoryInGB": 2
                    }
                  }
                }
              }
            ],
            "imageRegistryCredentials": [
              {
                "server": "${REGISTRY}",
                "username": "${ACR_USERNAME}",
                "password": "${ACR_PASSWORD}"
              }
            ],
            "osType": "Linux",
            "ipAddress": {
              "type": "Public",
              "ports": [
                {
                  "port": 8000,
                  "protocol": "TCP"
                }
              ],
              "dnsNameLabel": "elshawi-backend-${GITHUB_RUN_NUMBER}"
            },
            "restartPolicy": "Always"
          }
        }
        EOF
        )
        
        if create_container "elshawi-backend-${GITHUB_RUN_NUMBER}" "$BACKEND_SPEC"; then
          wait_for_container "elshawi-backend-${GITHUB_RUN_NUMBER}"
        else
          echo "âŒ Failed to create Backend container"
          exit 1
        fi

    - name: Deploy Frontend
      if: needs.detect-changes.outputs.should-deploy-frontend == 'true' && (needs.build-frontend.result == 'success' || needs.build-frontend.result == 'skipped')
      env:
        GITHUB_RUN_NUMBER: ${{ github.run_number }}
        GITHUB_SHA: ${{ github.sha }}
        REGISTRY: ${{ env.REGISTRY }}
        FRONTEND_IMAGE_NAME: ${{ env.FRONTEND_IMAGE_NAME }}
        ACR_USERNAME: ${{ secrets.ACR_USERNAME }}
        ACR_PASSWORD: ${{ secrets.ACR_PASSWORD }}
      run: |
        source azure_rest_helper.sh
        
        echo "ðŸš€ Deploying Frontend..."
        
        # Delete existing container if it exists
        if [ "${{ steps.check-deployments.outputs.frontend-exists }}" != "" ]; then
          delete_container "elshawi-frontend-${GITHUB_RUN_NUMBER}"
          sleep 10
        fi
        
        # Frontend container specification
        FRONTEND_SPEC=$(cat << EOF
        {
          "location": "westeurope",
          "properties": {
            "containers": [
              {
                "name": "frontend",
                "properties": {
                  "image": "${REGISTRY}/${FRONTEND_IMAGE_NAME}:latest",
                  "ports": [
                    {
                      "port": 3000,
                      "protocol": "TCP"
                    }
                  ],
                  "environmentVariables": [
                    {"name": "NEXT_PUBLIC_API_URL", "value": "https://elshawi-backend-${GITHUB_RUN_NUMBER}.westeurope.azurecontainer.io:8000"},
                    {"name": "NODE_ENV", "value": "production"}
                  ],
                  "resources": {
                    "requests": {
                      "cpu": 1,
                      "memoryInGB": 1.5
                    }
                  }
                }
              }
            ],
            "imageRegistryCredentials": [
              {
                "server": "${REGISTRY}",
                "username": "${ACR_USERNAME}",
                "password": "${ACR_PASSWORD}"
              }
            ],
            "osType": "Linux",
            "ipAddress": {
              "type": "Public",
              "ports": [
                {
                  "port": 3000,
                  "protocol": "TCP"
                }
              ],
              "dnsNameLabel": "elshawi-frontend-${GITHUB_RUN_NUMBER}"
            },
            "restartPolicy": "Always"
          }
        }
        EOF
        )
        
        if create_container "elshawi-frontend-${GITHUB_RUN_NUMBER}" "$FRONTEND_SPEC"; then
          wait_for_container "elshawi-frontend-${GITHUB_RUN_NUMBER}"
        else
          echo "âŒ Failed to create Frontend container"
          exit 1
        fi

    - name: Health Check
      env:
        GITHUB_RUN_NUMBER: ${{ github.run_number }}
      run: |
        echo "ðŸ¥ Performing health checks..."
        
        # Wait for containers to be fully ready
        sleep 30
        
        # Check backend health
        if [ "${{ needs.detect-changes.outputs.should-deploy-backend }}" == "true" ]; then
          echo "Checking backend health..."
          for i in {1..10}; do
            if curl -f -s --max-time 10 "https://elshawi-backend-${GITHUB_RUN_NUMBER}.westeurope.azurecontainer.io:8000/health/" > /dev/null 2>&1; then
              echo "âœ… Backend is healthy"
              break
            else
              echo "â³ Backend not ready yet, attempt $i/10"
              sleep 15
            fi
          done
        fi
        
        # Check frontend health
        if [ "${{ needs.detect-changes.outputs.should-deploy-frontend }}" == "true" ]; then
          echo "Checking frontend health..."
          for i in {1..10}; do
            if curl -f -s --max-time 10 "https://elshawi-frontend-${GITHUB_RUN_NUMBER}.westeurope.azurecontainer.io:3000" > /dev/null 2>&1; then
              echo "âœ… Frontend is healthy"
              break
            else
              echo "â³ Frontend not ready yet, attempt $i/10"
              sleep 15
            fi
          done
        fi

    - name: Get deployment URLs
      env:
        GITHUB_RUN_NUMBER: ${{ github.run_number }}
      run: |
        echo "ðŸš€ Deployment Complete!"
        echo "=================================="
        echo "ðŸ“Š Deployment Summary:"
        echo "Backend deployed: ${{ needs.detect-changes.outputs.should-deploy-backend }}"
        echo "Frontend deployed: ${{ needs.detect-changes.outputs.should-deploy-frontend }}"
        echo "Redis deployed: ${{ needs.detect-changes.outputs.should-deploy-redis }}"
        echo "=================================="
        echo "ðŸŒ Application URLs:"
        if [ "${{ needs.detect-changes.outputs.should-deploy-backend }}" == "true" ]; then
          echo "Backend API: https://elshawi-backend-${GITHUB_RUN_NUMBER}.westeurope.azurecontainer.io:8000"
          echo "Admin Panel: https://elshawi-backend-${GITHUB_RUN_NUMBER}.westeurope.azurecontainer.io:8000/admin/"
        fi
        if [ "${{ needs.detect-changes.outputs.should-deploy-frontend }}" == "true" ]; then
          echo "Frontend App: https://elshawi-frontend-${GITHUB_RUN_NUMBER}.westeurope.azurecontainer.io:3000"
        fi
        if [ "${{ needs.detect-changes.outputs.should-deploy-redis }}" == "true" ]; then
          echo "Redis: elshawi-redis-${GITHUB_RUN_NUMBER}.westeurope.azurecontainer.io:6379"
        fi
        echo "=================================="

  cleanup:
    needs: [azure-setup, deploy]
    runs-on: ubuntu-latest
    if: always() && needs.deploy.result == 'success'
    
    steps:
    - name: Setup Azure REST API for Cleanup
      env:
        AZURE_ACCESS_TOKEN: ${{ secrets.AZURE_ACCESS_TOKEN }}
        AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        AZURE_RESOURCE_GROUP: ${{ secrets.AZURE_RESOURCE_GROUP }}
      run: |
        # Create cleanup helper functions
        cat > cleanup_helper.sh << 'EOF'
        #!/bin/bash
        
        AZURE_TOKEN="${AZURE_ACCESS_TOKEN}"
        SUBSCRIPTION_ID="${AZURE_SUBSCRIPTION_ID}"
        RESOURCE_GROUP="${AZURE_RESOURCE_GROUP}"
        API_BASE="https://management.azure.com"
        
        azure_api_call() {
          local method="$1"
          local url="$2"
          
          curl -s -X "$method" \
            -H "Authorization: Bearer $AZURE_TOKEN" \
            -H "Content-Type: application/json" \
            "$url"
        }
        
        list_containers() {
          local url="$API_BASE/subscriptions/$SUBSCRIPTION_ID/resourceGroups/$RESOURCE_GROUP/providers/Microsoft.ContainerInstance/containerGroups?api-version=2021-09-01"
          azure_api_call "GET" "$url" | jq -r '.value[].name' 2>/dev/null | grep "^elshawi-" || true
        }
        
        delete_container() {
          local container_name="$1"
          local url="$API_BASE/subscriptions/$SUBSCRIPTION_ID/resourceGroups/$RESOURCE_GROUP/providers/Microsoft.ContainerInstance/containerGroups/$container_name?api-version=2021-09-01"
          azure_api_call "DELETE" "$url"
        }
        EOF
        
        chmod +x cleanup_helper.sh

    - name: Cleanup old deployments
      env:
        GITHUB_RUN_NUMBER: ${{ github.run_number }}
      run: |
        source cleanup_helper.sh
        
        echo