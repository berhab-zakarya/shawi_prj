name: Smart Deploy Full Stack App to Azure

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deploy all components'
        required: false
        default: false
        type: boolean
      component:
        description: 'Deploy specific component (backend/frontend/redis/all)'
        required: false
        default: 'all'
        type: choice
        options:
        - all
        - backend
        - frontend
        - redis

env:
  REGISTRY: ${{ secrets.ACR_REGISTRY }}
  BACKEND_IMAGE_NAME: elshawi-backend
  FRONTEND_IMAGE_NAME: elshawi-frontend
  AZURE_API_BASE: https://management.azure.com
  AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  AZURE_ACCESS_TOKEN: ${{ secrets.AZURE_ACCESS_TOKEN }}
  RESOURCE_GROUP: elshawi-rg
  # Use the Redis image that works
  REDIS_IMAGE: redis:alpine

jobs:
  azure-setup:
    runs-on: ubuntu-latest
    outputs:
      auth-verified: ${{ steps.verify-auth.outputs.verified }}
    steps:
    - name: Verify Azure Access Token
      id: verify-auth
      env:
        AZURE_ACCESS_TOKEN: ${{ secrets.AZURE_ACCESS_TOKEN }}
        AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        AZURE_RESOURCE_GROUP: ${{ secrets.AZURE_RESOURCE_GROUP }}
      run: |
        echo "üîê Verifying Azure access token..."
        echo "üîç Subscription ID: $AZURE_SUBSCRIPTION_ID"
        echo "üîç Resource Group: $RESOURCE_GROUP"
        
        # Test the access token with subscription info
        HTTP_CODE=$(curl -s -w "%{http_code}" -o /tmp/sub_response.json \
          -H "Authorization: Bearer ${AZURE_ACCESS_TOKEN}" \
          -H "Content-Type: application/json" \
          "${AZURE_API_BASE}/subscriptions/${AZURE_SUBSCRIPTION_ID}?api-version=2025-04-01")
        
        if [ "$HTTP_CODE" = "200" ]; then
          echo "‚úÖ Access token is valid"
          SUB_NAME=$(cat /tmp/sub_response.json | jq -r '.displayName')
          echo "üìã Subscription: $SUB_NAME"
          echo "verified=true" >> $GITHUB_OUTPUT
        else
          echo "‚ùå Access token validation failed with HTTP code: $HTTP_CODE"
          cat /tmp/sub_response.json
          echo "verified=false" >> $GITHUB_OUTPUT
          exit 1
        fi

  detect-changes:
    needs: azure-setup
    runs-on: ubuntu-latest
    outputs:
      backend-changed: ${{ steps.changes.outputs.backend }}
      frontend-changed: ${{ steps.changes.outputs.frontend }}
      docker-changed: ${{ steps.changes.outputs.docker }}
      workflow-changed: ${{ steps.changes.outputs.workflow }}
      force-deploy: ${{ github.event.inputs.force_deploy == 'true' || github.event_name == 'workflow_dispatch' }}
      deploy-component: ${{ github.event.inputs.component || 'all' }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Detect file changes
      uses: dorny/paths-filter@v2
      id: changes
      with:
        filters: |
          backend:
            - 'backend/**'
            - 'requirements.txt'
            - 'pyproject.toml'
            - 'poetry.lock'
          frontend:
            - 'frontend/**'
            - 'package.json'
            - 'package-lock.json'
            - 'yarn.lock'
            - 'pnpm-lock.yaml'
          docker:
            - '**/Dockerfile*'
            - '**/.dockerignore'
            - 'docker-compose*'
          workflow:
            - '.github/workflows/**'

    - name: Show detected changes
      run: |
        echo "üîç Change Detection Results:"
        echo "=================================="
        echo "Backend changed: ${{ steps.changes.outputs.backend }}"
        echo "Frontend changed: ${{ steps.changes.outputs.frontend }}"
        echo "Docker files changed: ${{ steps.changes.outputs.docker }}"
        echo "Workflow changed: ${{ steps.changes.outputs.workflow }}"
        echo "Force deploy: ${{ github.event.inputs.force_deploy == 'true' }}"
        echo "Deploy component: ${{ github.event.inputs.component || 'all' }}"
        echo "=================================="

  build-backend:
    needs: [azure-setup, detect-changes]
    runs-on: ubuntu-latest
    if: |
      needs.detect-changes.outputs.backend-changed == 'true' || 
      needs.detect-changes.outputs.docker-changed == 'true' ||
      needs.detect-changes.outputs.force-deploy == 'true' ||
      (needs.detect-changes.outputs.deploy-component == 'all' || needs.detect-changes.outputs.deploy-component == 'backend')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Azure Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ secrets.ACR_USERNAME }}
        password: ${{ secrets.ACR_PASSWORD }}

    - name: Build and push Backend (Django) image
      uses: docker/build-push-action@v5
      with:
        context: ./backend
        file: ./backend/Dockerfile.prod
        push: true
        tags: |
          ${{ env.REGISTRY }}/${{ env.BACKEND_IMAGE_NAME }}:${{ github.sha }}
          ${{ env.REGISTRY }}/${{ env.BACKEND_IMAGE_NAME }}:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64

  build-frontend:
    needs: [azure-setup, detect-changes]
    runs-on: ubuntu-latest
    if: |
      needs.detect-changes.outputs.frontend-changed == 'true' || 
      needs.detect-changes.outputs.docker-changed == 'true' ||
      needs.detect-changes.outputs.force-deploy == 'true' ||
      (needs.detect-changes.outputs.deploy-component == 'all' || needs.detect-changes.outputs.deploy-component == 'frontend')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Azure Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ secrets.ACR_USERNAME }}
        password: ${{ secrets.ACR_PASSWORD }}

    - name: Build and push Frontend (Next.js) image
      uses: docker/build-push-action@v5
      with:
        context: ./frontend
        file: ./frontend/Dockerfile.prod
        push: true
        tags: |
          ${{ env.REGISTRY }}/${{ env.FRONTEND_IMAGE_NAME }}:${{ github.sha }}
          ${{ env.REGISTRY }}/${{ env.FRONTEND_IMAGE_NAME }}:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64

  deploy:
    needs: [azure-setup, detect-changes, build-backend, build-frontend]
    runs-on: ubuntu-latest
    if: always() && !cancelled() && !failure()
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Azure REST API Helper Functions
      env:
        AZURE_ACCESS_TOKEN: ${{ secrets.AZURE_ACCESS_TOKEN }}
        AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        AZURE_RESOURCE_GROUP: ${{ secrets.AZURE_RESOURCE_GROUP }}
      run: |
        echo "üîß Setting up Azure REST API helper functions..."
        cat > azure_rest_helper.sh << 'EOF'
        #!/bin/bash
        
        AZURE_TOKEN="${AZURE_ACCESS_TOKEN}"
        SUBSCRIPTION_ID="${AZURE_SUBSCRIPTION_ID}"
        RESOURCE_GROUP="${AZURE_RESOURCE_GROUP:-${RESOURCE_GROUP:-elshawi-rg}}"
        API_BASE="https://management.azure.com"
        
        azure_api_call() {
          local method="$1"
          local url="$2"
          local data="$3"
          echo "üîç Making API call: $method $url" >&2
          if [ -n "$data" ]; then
            curl -s -w "\nHTTP_CODE:%{http_code}" -X "$method" \
              -H "Authorization: Bearer $AZURE_TOKEN" \
              -H "Content-Type: application/json" \
              -d "$data" \
              "$url"
          else
            curl -s -w "\nHTTP_CODE:%{http_code}" -X "$method" \
              -H "Authorization: Bearer $AZURE_TOKEN" \
              -H "Content-Type: application/json" \
              "$url"
          fi
        }
        
        check_container_exists() {
          local container_name="$1"
          local url="$API_BASE/subscriptions/$SUBSCRIPTION_ID/resourceGroups/$RESOURCE_GROUP/providers/Microsoft.ContainerInstance/containerGroups/$container_name?api-version=2023-05-01"
          echo "üîç Checking if container exists: $container_name" >&2
          local response=$(azure_api_call "GET" "$url")
          local http_code=$(echo "$response" | tail -1 | sed 's/.*HTTP_CODE://')
          local json_response=$(echo "$response" | sed '$d')
          if [ "$http_code" = "200" ]; then
            echo "$json_response" | jq -r '.name // empty' 2>/dev/null
          else
            echo ""
          fi
        }
        
        delete_container() {
          local container_name="$1"
          local url="$API_BASE/subscriptions/$SUBSCRIPTION_ID/resourceGroups/$RESOURCE_GROUP/providers/Microsoft.ContainerInstance/containerGroups/$container_name?api-version=2023-05-01"
          echo "üóëÔ∏è Deleting container: $container_name" >&2
          local response=$(azure_api_call "DELETE" "$url")
          local http_code=$(echo "$response" | tail -1 | sed 's/.*HTTP_CODE://')
          if [ "$http_code" = "200" ] || [ "$http_code" = "204" ]; then
            echo "‚úÖ Container deletion initiated successfully" >&2
            return 0
          else
            echo "‚ùå Container deletion failed with HTTP code: $http_code" >&2
            echo "$response" >&2
            return 1
          fi
        }
        
        create_container() {
          local container_name="$1"
          local container_spec="$2"
          local url="$API_BASE/subscriptions/$SUBSCRIPTION_ID/resourceGroups/$RESOURCE_GROUP/providers/Microsoft.ContainerInstance/containerGroups/$container_name?api-version=2023-05-01"
          if [ -z "$SUBSCRIPTION_ID" ] || [ -z "$RESOURCE_GROUP" ] || [ -z "$AZURE_TOKEN" ]; then
            echo "‚ùå Missing required environment variables: SUBSCRIPTION_ID, RESOURCE_GROUP, or AZURE_TOKEN" >&2
            exit 1
          fi
          echo "üöÄ Creating container: $container_name" >&2
          echo "üìç URL: $url" >&2
          local response=$(azure_api_call "PUT" "$url" "$container_spec")
          local http_code=$(echo "$response" | tail -1 | sed 's/.*HTTP_CODE://')
          local json_response=$(echo "$response" | sed '$d')
          if [ "$http_code" = "200" ] || [ "$http_code" = "201" ]; then
            echo "‚úÖ Container creation initiated successfully" >&2
            echo "$json_response" | jq '.properties.provisioningState // "Unknown"' 2>/dev/null >&2
            return 0
          else
            echo "‚ùå Container creation failed with HTTP code: $http_code" >&2
            echo "$json_response" >&2
            return 1
          fi
        }
        
        wait_for_container_ready() {
          local container_name="$1"
          local timeout="${2:-300}"  # 5 minutes default
          local interval=15
          local elapsed=0
          
          echo "‚è≥ Waiting for container to be ready: $container_name" >&2
          
          while [ $elapsed -lt $timeout ]; do
            local url="$API_BASE/subscriptions/$SUBSCRIPTION_ID/resourceGroups/$RESOURCE_GROUP/providers/Microsoft.ContainerInstance/containerGroups/$container_name?api-version=2023-05-01"
            local response=$(azure_api_call "GET" "$url")
            local http_code=$(echo "$response" | tail -1 | sed 's/.*HTTP_CODE://')
            local json_response=$(echo "$response" | sed '$d')
            
            if [ "$http_code" = "200" ]; then
              local state=$(echo "$json_response" | jq -r '.properties.instanceView.state // "Unknown"' 2>/dev/null)
              local provisioning_state=$(echo "$json_response" | jq -r '.properties.provisioningState // "Unknown"' 2>/dev/null)
              
              echo "Container $container_name - State: $state, Provisioning: $provisioning_state" >&2
              
              if [ "$state" = "Running" ] && [ "$provisioning_state" = "Succeeded" ]; then
                echo "‚úÖ Container $container_name is ready!" >&2
                return 0
              fi
            fi
            
            sleep $interval
            elapsed=$((elapsed + interval))
          done
          
          echo "‚ö†Ô∏è Container $container_name did not become ready within $timeout seconds" >&2
          return 1
        }
        
        check_redis_health() {
          local redis_host="$1"
          local redis_port="${2:-6379}"
          local timeout="${3:-60}"
          
          echo "üè• Checking Redis health at $redis_host:$redis_port" >&2
          local elapsed=0
          local interval=10
          
          while [ $elapsed -lt $timeout ]; do
            if timeout 5 bash -c "</dev/tcp/$redis_host/$redis_port" 2>/dev/null; then
              echo "‚úÖ Redis is responding on $redis_host:$redis_port" >&2
              return 0
            else
              echo "‚è≥ Redis not ready yet, waiting..." >&2
              sleep $interval
              elapsed=$((elapsed + interval))
            fi
          done
          
          echo "‚ùå Redis health check failed after $timeout seconds" >&2
          return 1
        }
        EOF
        chmod +x azure_rest_helper.sh

    - name: Check existing deployments
      id: check-deployments
      env:
        GITHUB_RUN_NUMBER: ${{ github.run_number }}
      run: |
        source azure_rest_helper.sh
        
        echo "üîç Checking existing deployments..."
        
        # Check if containers already exist
        REDIS_EXISTS=$(check_container_exists "elshawi-redis-${GITHUB_RUN_NUMBER}")
        BACKEND_EXISTS=$(check_container_exists "elshawi-backend-${GITHUB_RUN_NUMBER}")
        FRONTEND_EXISTS=$(check_container_exists "elshawi-frontend-${GITHUB_RUN_NUMBER}")
        
        echo "redis-exists=${REDIS_EXISTS}" >> $GITHUB_OUTPUT
        echo "backend-exists=${BACKEND_EXISTS}" >> $GITHUB_OUTPUT
        echo "frontend-exists=${FRONTEND_EXISTS}" >> $GITHUB_OUTPUT
        
        echo "Redis exists: ${REDIS_EXISTS:-none}"
        echo "Backend exists: ${BACKEND_EXISTS:-none}"
        echo "Frontend exists: ${FRONTEND_EXISTS:-none}"

    - name: Deploy Redis (Priority - Always First)
      if: |
        steps.check-deployments.outputs.redis-exists == '' &&
        (needs.detect-changes.outputs.backend-changed == 'true' || 
        needs.detect-changes.outputs.force-deploy == 'true' ||
        needs.detect-changes.outputs.deploy-component == 'all' ||
        needs.detect-changes.outputs.deploy-component == 'redis')
      env:
        GITHUB_RUN_NUMBER: ${{ github.run_number }}
        AZURE_RESOURCE_GROUP: ${{ secrets.AZURE_RESOURCE_GROUP }}
        # Docker Hub credentials for authentication
        DOCKER_HUB_USERNAME: ${{ secrets.DOCKER_HUB_USERNAME }}
        DOCKER_HUB_TOKEN: ${{ secrets.DOCKER_HUB_TOKEN }}
      run: |
        source azure_rest_helper.sh
        echo "üöÄ Deploying Redis with Docker Hub authentication..."
        echo "üîç Subscription ID: $AZURE_SUBSCRIPTION_ID"
        echo "üîç Resource Group: $AZURE_RESOURCE_GROUP"
        
        # Try multiple Redis images with retry logic
        declare -a REDIS_IMAGES=(
          "redis:7-alpine"
          "redis:7"
          "redis:alpine"
          "redis:latest"
        )
        
        SUCCESS=false
        
        for IMAGE in "${REDIS_IMAGES[@]}"; do
          echo "üîÑ Trying Redis image: $IMAGE"
          
          # Redis container specification WITH Docker Hub credentials
          REDIS_SPEC='
          {
            "location": "westeurope",
            "properties": {
              "containers": [
                {
                  "name": "redis",
                  "properties": {
                    "image": "'"$IMAGE"'",
                    "command": ["redis-server", "--appendonly", "yes", "--maxmemory", "256mb", "--maxmemory-policy", "allkeys-lru"],
                    "ports": [
                      {
                        "port": 6379,
                        "protocol": "TCP"
                      }
                    ],
                    "resources": {
                      "requests": {
                        "cpu": 0.5,
                        "memoryInGB": 0.5
                      }
                    }
                  }
                }
              ],
              "imageRegistryCredentials": [
                {
                  "server": "index.docker.io",
                  "username": "'"${DOCKER_HUB_USERNAME}"'",
                  "password": "'"${DOCKER_HUB_TOKEN}"'"
                }
              ],
              "osType": "Linux",
              "ipAddress": {
                "type": "Public",
                "ports": [
                  {
                    "port": 6379,
                    "protocol": "TCP"
                  }
                ],
                "dnsNameLabel": "elshawi-redis-'"${GITHUB_RUN_NUMBER}"'"
              },
              "restartPolicy": "Always"
            }
          }'
          
          # Try creating the container with this image
          MAX_ATTEMPTS=3
          ATTEMPT=1
          
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "üîÑ Attempt $ATTEMPT of $MAX_ATTEMPTS for image $IMAGE"
            
            if create_container "elshawi-redis-${GITHUB_RUN_NUMBER}" "$REDIS_SPEC"; then
              echo "‚úÖ Redis container created successfully with image: $IMAGE"
              SUCCESS=true
              break 2  # Break out of both loops
            else
              echo "‚ùå Attempt $ATTEMPT failed for image $IMAGE"
              if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
                echo "‚è≥ Waiting 20 seconds before retry..."
                sleep 20
              fi
            fi
            
            ATTEMPT=$((ATTEMPT + 1))
          done
          
          echo "‚è≥ Waiting 15 seconds before trying next image..."
          sleep 15
        done
        
        if [ "$SUCCESS" != "true" ]; then
          echo "‚ùå All Redis images failed. Trying fallback approach without Docker Hub auth..."
          
          # Fallback: Try without Docker Hub authentication
          REDIS_SPEC_FALLBACK='
          {
            "location": "westeurope",
            "properties": {
              "containers": [
                {
                  "name": "redis",
                  "properties": {
                    "image": "redis:alpine",
                    "command": ["redis-server", "--appendonly", "yes", "--maxmemory", "256mb", "--maxmemory-policy", "allkeys-lru"],
                    "ports": [
                      {
                        "port": 6379,
                        "protocol": "TCP"
                      }
                    ],
                    "resources": {
                      "requests": {
                        "cpu": 0.5,
                        "memoryInGB": 0.5
                      }
                    }
                  }
                }
              ],
              "osType": "Linux",
              "ipAddress": {
                "type": "Public",
                "ports": [
                  {
                    "port": 6379,
                    "protocol": "TCP"
                  }
                ],
                "dnsNameLabel": "elshawi-redis-'"${GITHUB_RUN_NUMBER}"'"
              },
              "restartPolicy": "Always"
            }
          }'
          
          if create_container "elshawi-redis-${GITHUB_RUN_NUMBER}" "$REDIS_SPEC_FALLBACK"; then
            echo "‚úÖ Redis container created with fallback approach"
            SUCCESS=true
          else
            echo "‚ùå Even fallback approach failed. Deployment cannot continue without Redis."
            exit 1
          fi
        fi
        
        echo "‚è≥ Waiting for Redis to be ready..."
        sleep 30
        
        # Verify Redis is running
        if wait_for_container_ready "elshawi-redis-${GITHUB_RUN_NUMBER}" 180; then
          echo "‚úÖ Redis container is running"
          # Additional Redis health check
          check_redis_health "elshawi-redis-${GITHUB_RUN_NUMBER}.westeurope.azurecontainer.io" 6379 120
        else
          echo "‚ö†Ô∏è Redis container may not be fully ready, but continuing..."
        fi

    - name: Verify Redis Before Backend Deployment
      env:
        GITHUB_RUN_NUMBER: ${{ github.run_number }}
      run: |
        source azure_rest_helper.sh
        
        echo "üîç Verifying Redis is accessible before deploying backend..."
        REDIS_HOST="elshawi-redis-${GITHUB_RUN_NUMBER}.westeurope.azurecontainer.io"
        
        # Double-check Redis health before proceeding
        if check_redis_health "$REDIS_HOST" 6379 60; then
          echo "‚úÖ Redis verified and ready for backend connection"
        else
          echo "‚ö†Ô∏è Redis verification failed, but continuing with deployment"
          echo "üîç Backend will include retry logic for Redis connections"
        fi

    - name: Deploy Backend (After Redis)
      if: |
        needs.build-backend.result == 'success' ||
        (needs.detect-changes.outputs.force-deploy == 'true' && 
         (needs.detect-changes.outputs.deploy-component == 'all' || needs.detect-changes.outputs.deploy-component == 'backend'))
      env:
        GITHUB_RUN_NUMBER: ${{ github.run_number }}
        GITHUB_SHA: ${{ github.sha }}
        REGISTRY: ${{ env.REGISTRY }}
        BACKEND_IMAGE_NAME: ${{ env.BACKEND_IMAGE_NAME }}
        DJANGO_SECRET_KEY: ${{ secrets.DJANGO_SECRET_KEY }}
        ACR_USERNAME: ${{ secrets.ACR_USERNAME }}
        ACR_PASSWORD: ${{ secrets.ACR_PASSWORD }}
      run: |
        source azure_rest_helper.sh
        
        echo "üöÄ Deploying Backend (after Redis verification)..."
        
        # Delete existing container if it exists
        if [ "${{ steps.check-deployments.outputs.backend-exists }}" != "" ]; then
          if delete_container "elshawi-backend-${GITHUB_RUN_NUMBER}"; then
            echo "‚è≥ Waiting for deletion to complete..."
            sleep 30
          fi
        fi
        
        # Backend container specification with improved health check endpoint
        BACKEND_SPEC='
        {
          "location": "westeurope",
          "properties": {
            "containers": [
              {
                "name": "backend",
                "properties": {
                  "image": "'"${REGISTRY}/${BACKEND_IMAGE_NAME}:${GITHUB_SHA}"'",
                  "ports": [
                    {
                      "port": 8000,
                      "protocol": "TCP"
                    }
                  ],
                  "environmentVariables": [
                    {"name": "DJANGO_SECRET_KEY", "value": "'"${DJANGO_SECRET_KEY}"'"},
                    {"name": "DJANGO_DEBUG", "value": "False"},
                    {"name": "DJANGO_ALLOWED_HOSTS", "value": "elshawi-backend-'"${GITHUB_RUN_NUMBER}"'.westeurope.azurecontainer.io,localhost,*"},
                    {"name": "REDIS_URL", "value": "redis://elshawi-redis-'"${GITHUB_RUN_NUMBER}"'.westeurope.azurecontainer.io:6379"},
                    {"name": "DATABASE_URL", "value": "sqlite:///db.sqlite3"},
                    {"name": "CORS_ALLOWED_ORIGINS", "value": "https://elshawi-frontend-'"${GITHUB_RUN_NUMBER}"'.westeurope.azurecontainer.io,http://localhost:3000"},
                    {"name": "GUNICORN_WORKERS", "value": "2"},
                    {"name": "GUNICORN_TIMEOUT", "value": "60"},
                    {"name": "GUNICORN_BIND", "value": "0.0.0.0:8000"}
                  ],
                  "resources": {
                    "requests": {
                      "cpu": 1,
                      "memoryInGB": 2
                    }
                  }
                }
              }
            ],
            "imageRegistryCredentials": [
              {
                "server": "'"${REGISTRY}"'",
                "username": "'"${ACR_USERNAME}"'",
                "password": "'"${ACR_PASSWORD}"'"
              }
            ],
            "osType": "Linux",
            "ipAddress": {
              "type": "Public",
              "ports": [
                {
                  "port": 8000,
                  "protocol": "TCP"
                }
              ],
              "dnsNameLabel": "elshawi-backend-'"${GITHUB_RUN_NUMBER}"'"
            },
            "restartPolicy": "Always"
          }
        }'
        
        if create_container "elshawi-backend-${GITHUB_RUN_NUMBER}" "$BACKEND_SPEC"; then
          echo "‚úÖ Backend container creation initiated"
          wait_for_container_ready "elshawi-backend-${GITHUB_RUN_NUMBER}" 300
        else
          echo "‚ùå Backend deployment failed"
          exit 1
        fi

    - name: Deploy Frontend (Final Step)
      if: |
        needs.build-frontend.result == 'success' ||
        (needs.detect-changes.outputs.force-deploy == 'true' && 
         (needs.detect-changes.outputs.deploy-component == 'all' || needs.detect-changes.outputs.deploy-component == 'frontend'))
      env:
        GITHUB_RUN_NUMBER: ${{ github.run_number }}
        GITHUB_SHA: ${{ github.sha }}
        REGISTRY: ${{ env.REGISTRY }}
        FRONTEND_IMAGE_NAME: ${{ env.FRONTEND_IMAGE_NAME }}
        ACR_USERNAME: ${{ secrets.ACR_USERNAME }}
        ACR_PASSWORD: ${{ secrets.ACR_PASSWORD }}
      run: |
        source azure_rest_helper.sh
        
        echo "üöÄ Deploying Frontend (final step)..."
        
        # Delete existing container if it exists
        if [ "${{ steps.check-deployments.outputs.frontend-exists }}" != "" ]; then
          if delete_container "elshawi-frontend-${GITHUB_RUN_NUMBER}"; then
            echo "‚è≥ Waiting for deletion to complete..."
            sleep 30
          fi
        fi
        
        # Frontend container specification with corrected API URL
        FRONTEND_SPEC='
        {
          "location": "westeurope",
          "properties": {
            "containers": [
              {
                "name": "frontend",
                "properties": {
                  "image": "'"${REGISTRY}/${FRONTEND_IMAGE_NAME}:${GITHUB_SHA}"'",
                  "ports": [
                    {
                      "port": 3000,
                      "protocol": "TCP"
                    }
                  ],
                  "environmentVariables": [
                    {"name": "NEXT_PUBLIC_API_URL", "value": "http://elshawi-backend-'"${GITHUB_RUN_NUMBER}"'.westeurope.azurecontainer.io:8000"},
                    {"name": "NODE_ENV", "value": "production"},
                    {"name": "PORT", "value": "3000"}
                  ],
                  "resources": {
                    "requests": {
                      "cpu": 1,
                      "memoryInGB": 1.5
                    }
                  }
                }
              }
            ],
            "imageRegistryCredentials": [
              {
                "server": "'"${REGISTRY}"'",
                "username": "'"${ACR_USERNAME}"'",
                "password": "'"${ACR_PASSWORD}"'"
              }
            ],
            "osType": "Linux",
            "ipAddress": {
              "type": "Public",
              "ports": [
                {
                  "port": 3000,
                  "protocol": "TCP"
                }
              ],
              "dnsNameLabel": "elshawi-frontend-'"${GITHUB_RUN_NUMBER}"'"
            },
            "restartPolicy": "Always"
          }
        }'
        
        if create_container "elshawi-frontend-${GITHUB_RUN_NUMBER}" "$FRONTEND_SPEC"; then
          echo "‚úÖ Frontend container creation initiated"
          wait_for_container_ready "elshawi-frontend-${GITHUB_RUN_NUMBER}" 300
        else
          echo "‚ùå Frontend deployment failed"
          exit 1